{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Directive, Input, IterableDiffers, NgZone } from '@angular/core';\nimport { LeafletDirective } from '../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nvar LeafletLayersDirective = /** @class */function () {\n  function LeafletLayersDirective(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  }\n  Object.defineProperty(LeafletLayersDirective.prototype, \"layers\", {\n    get: function () {\n      return this.layersValue;\n    },\n    // Set/get the layers\n    set: function (v) {\n      this.layersValue = v;\n      // Now that we have a differ, do an immediate layer update\n      this.updateLayers();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  LeafletLayersDirective.prototype.ngDoCheck = function () {\n    this.updateLayers();\n  };\n  LeafletLayersDirective.prototype.ngOnInit = function () {\n    // Init the map\n    this.leafletDirective.init();\n    // Update layers once the map is ready\n    this.updateLayers();\n  };\n  LeafletLayersDirective.prototype.ngOnDestroy = function () {\n    this.layers = [];\n  };\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n  LeafletLayersDirective.prototype.updateLayers = function () {\n    var map = this.leafletDirective.getMap();\n    if (null != map && null != this.layersDiffer) {\n      var changes_1 = this.layersDiffer.diff(this.layersValue);\n      if (null != changes_1) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(function () {\n          changes_1.forEachRemovedItem(function (c) {\n            map.removeLayer(c.item);\n          });\n          changes_1.forEachAddedItem(function (c) {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  };\n  __decorate([Input('leafletLayers'), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], LeafletLayersDirective.prototype, \"layers\", null);\n  LeafletLayersDirective = __decorate([Directive({\n    selector: '[leafletLayers]'\n  }), __metadata(\"design:paramtypes\", [LeafletDirective, IterableDiffers, NgZone])], LeafletLayersDirective);\n  return LeafletLayersDirective;\n}();\nexport { LeafletLayersDirective };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","Directive","Input","IterableDiffers","NgZone","LeafletDirective","LeafletDirectiveWrapper","LeafletLayersDirective","leafletDirective","differs","zone","layersDiffer","find","create","prototype","get","layersValue","set","updateLayers","enumerable","configurable","ngDoCheck","ngOnInit","init","ngOnDestroy","layers","map","getMap","changes_1","diff","runOutsideAngular","forEachRemovedItem","removeLayer","item","forEachAddedItem","addLayer","Array","selector"],"sources":["C:/Users/safia/submissions_map/submissions_map/node_modules/@asymmetrik/ngx-leaflet/dist/leaflet/layers/leaflet-layers.directive.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Directive, Input, IterableDiffers, NgZone } from '@angular/core';\nimport { LeafletDirective } from '../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nvar LeafletLayersDirective = /** @class */ (function () {\n    function LeafletLayersDirective(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    Object.defineProperty(LeafletLayersDirective.prototype, \"layers\", {\n        get: function () {\n            return this.layersValue;\n        },\n        // Set/get the layers\n        set: function (v) {\n            this.layersValue = v;\n            // Now that we have a differ, do an immediate layer update\n            this.updateLayers();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LeafletLayersDirective.prototype.ngDoCheck = function () {\n        this.updateLayers();\n    };\n    LeafletLayersDirective.prototype.ngOnInit = function () {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    };\n    LeafletLayersDirective.prototype.ngOnDestroy = function () {\n        this.layers = [];\n    };\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    LeafletLayersDirective.prototype.updateLayers = function () {\n        var map = this.leafletDirective.getMap();\n        if (null != map && null != this.layersDiffer) {\n            var changes_1 = this.layersDiffer.diff(this.layersValue);\n            if (null != changes_1) {\n                // Run outside angular to ensure layer events don't trigger change detection\n                this.zone.runOutsideAngular(function () {\n                    changes_1.forEachRemovedItem(function (c) {\n                        map.removeLayer(c.item);\n                    });\n                    changes_1.forEachAddedItem(function (c) {\n                        map.addLayer(c.item);\n                    });\n                });\n            }\n        }\n    };\n    __decorate([\n        Input('leafletLayers'),\n        __metadata(\"design:type\", Array),\n        __metadata(\"design:paramtypes\", [Array])\n    ], LeafletLayersDirective.prototype, \"layers\", null);\n    LeafletLayersDirective = __decorate([\n        Directive({\n            selector: '[leafletLayers]'\n        }),\n        __metadata(\"design:paramtypes\", [LeafletDirective, IterableDiffers, NgZone])\n    ], LeafletLayersDirective);\n    return LeafletLayersDirective;\n}());\nexport { LeafletLayersDirective };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}