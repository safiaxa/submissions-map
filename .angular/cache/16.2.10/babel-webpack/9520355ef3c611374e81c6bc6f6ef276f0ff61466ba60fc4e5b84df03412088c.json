{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Directive, EventEmitter, Input, KeyValueDiffers, NgZone, Output } from '@angular/core';\nimport { Control } from 'leaflet';\nimport { LeafletUtil } from '../../core/leaflet.util';\nimport { LeafletDirective } from '../../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../../core/leaflet.directive.wrapper';\nimport { LeafletControlLayersWrapper } from '../control/leaflet-control-layers.wrapper';\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nvar LeafletBaseLayersDirective = /** @class */function () {\n  function LeafletBaseLayersDirective(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    // Output for once the layers control is ready\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    this.baseLayersDiffer = this.differs.find({}).create();\n  }\n  Object.defineProperty(LeafletBaseLayersDirective.prototype, \"baseLayers\", {\n    get: function () {\n      return this.baseLayersValue;\n    },\n    // Set/get baseLayers\n    set: function (v) {\n      this.baseLayersValue = v;\n      this.updateBaseLayers();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  LeafletBaseLayersDirective.prototype.ngOnDestroy = function () {\n    this.baseLayers = {};\n    this.controlLayers.getLayersControl().remove();\n  };\n  LeafletBaseLayersDirective.prototype.ngOnInit = function () {\n    var _this = this;\n    // Init the map\n    this.leafletDirective.init();\n    // Create the control outside angular to prevent events from triggering chnage detection\n    this.zone.runOutsideAngular(function () {\n      // Initially configure the controlLayers\n      _this.controlLayers.init({}, _this.layersControlOptions).addTo(_this.leafletDirective.getMap());\n    });\n    this.updateBaseLayers();\n  };\n  LeafletBaseLayersDirective.prototype.ngDoCheck = function () {\n    this.updateBaseLayers();\n  };\n  LeafletBaseLayersDirective.prototype.updateBaseLayers = function () {\n    var map = this.leafletDirective.getMap();\n    var layersControl = this.controlLayers.getLayersControl();\n    if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n      var changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n      var results = this.controlLayers.applyBaseLayerChanges(changes);\n      if (results.changed()) {\n        this.syncBaseLayer();\n      }\n    }\n  };\n  /**\n   * Check the current base layer and change it to the new one if necessary\n   */\n  LeafletBaseLayersDirective.prototype.syncBaseLayer = function () {\n    var _this = this;\n    var map = this.leafletDirective.getMap();\n    var layers = LeafletUtil.mapToArray(this.baseLayers);\n    var foundLayer;\n    // Search all the layers in the map to see if we can find them in the baselayer array\n    map.eachLayer(function (l) {\n      foundLayer = layers.find(function (bl) {\n        return l === bl;\n      });\n    });\n    // Did we find the layer?\n    if (null != foundLayer) {\n      // Yes - set the baselayer to the one we found\n      this.baseLayer = foundLayer;\n    } else {\n      // No - set the baselayer to the first in the array and add it to the map\n      if (layers.length > 0) {\n        this.baseLayer = layers[0];\n        // Add layers outside of angular to prevent events from triggering change detection\n        this.zone.runOutsideAngular(function () {\n          _this.baseLayer.addTo(map);\n        });\n      }\n    }\n  };\n  __decorate([Input('leafletBaseLayers'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], LeafletBaseLayersDirective.prototype, \"baseLayers\", null);\n  __decorate([Input('leafletLayersControlOptions'), __metadata(\"design:type\", Object)], LeafletBaseLayersDirective.prototype, \"layersControlOptions\", void 0);\n  __decorate([Output('leafletLayersControlReady'), __metadata(\"design:type\", Object)], LeafletBaseLayersDirective.prototype, \"layersControlReady\", void 0);\n  LeafletBaseLayersDirective = __decorate([Directive({\n    selector: '[leafletBaseLayers]'\n  }), __metadata(\"design:paramtypes\", [LeafletDirective, KeyValueDiffers, NgZone])], LeafletBaseLayersDirective);\n  return LeafletBaseLayersDirective;\n}();\nexport { LeafletBaseLayersDirective };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","Directive","EventEmitter","Input","KeyValueDiffers","NgZone","Output","Control","LeafletUtil","LeafletDirective","LeafletDirectiveWrapper","LeafletControlLayersWrapper","LeafletBaseLayersDirective","leafletDirective","differs","zone","layersControlReady","controlLayers","baseLayersDiffer","find","create","prototype","get","baseLayersValue","set","updateBaseLayers","enumerable","configurable","ngOnDestroy","baseLayers","getLayersControl","remove","ngOnInit","_this","init","runOutsideAngular","layersControlOptions","addTo","getMap","ngDoCheck","map","layersControl","changes","diff","results","applyBaseLayerChanges","changed","syncBaseLayer","layers","mapToArray","foundLayer","eachLayer","l","bl","baseLayer","selector"],"sources":["C:/Users/safia/submissions_map/submissions_map/node_modules/@asymmetrik/ngx-leaflet/dist/leaflet/layers/base/leaflet-baselayers.directive.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nimport { Directive, EventEmitter, Input, KeyValueDiffers, NgZone, Output } from '@angular/core';\nimport { Control } from 'leaflet';\nimport { LeafletUtil } from '../../core/leaflet.util';\nimport { LeafletDirective } from '../../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../../core/leaflet.directive.wrapper';\nimport { LeafletControlLayersWrapper } from '../control/leaflet-control-layers.wrapper';\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nvar LeafletBaseLayersDirective = /** @class */ (function () {\n    function LeafletBaseLayersDirective(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        // Output for once the layers control is ready\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        this.baseLayersDiffer = this.differs.find({}).create();\n    }\n    Object.defineProperty(LeafletBaseLayersDirective.prototype, \"baseLayers\", {\n        get: function () {\n            return this.baseLayersValue;\n        },\n        // Set/get baseLayers\n        set: function (v) {\n            this.baseLayersValue = v;\n            this.updateBaseLayers();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LeafletBaseLayersDirective.prototype.ngOnDestroy = function () {\n        this.baseLayers = {};\n        this.controlLayers.getLayersControl().remove();\n    };\n    LeafletBaseLayersDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        // Init the map\n        this.leafletDirective.init();\n        // Create the control outside angular to prevent events from triggering chnage detection\n        this.zone.runOutsideAngular(function () {\n            // Initially configure the controlLayers\n            _this.controlLayers\n                .init({}, _this.layersControlOptions)\n                .addTo(_this.leafletDirective.getMap());\n        });\n        this.updateBaseLayers();\n    };\n    LeafletBaseLayersDirective.prototype.ngDoCheck = function () {\n        this.updateBaseLayers();\n    };\n    LeafletBaseLayersDirective.prototype.updateBaseLayers = function () {\n        var map = this.leafletDirective.getMap();\n        var layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n            var changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n            var results = this.controlLayers.applyBaseLayerChanges(changes);\n            if (results.changed()) {\n                this.syncBaseLayer();\n            }\n        }\n    };\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n    LeafletBaseLayersDirective.prototype.syncBaseLayer = function () {\n        var _this = this;\n        var map = this.leafletDirective.getMap();\n        var layers = LeafletUtil.mapToArray(this.baseLayers);\n        var foundLayer;\n        // Search all the layers in the map to see if we can find them in the baselayer array\n        map.eachLayer(function (l) {\n            foundLayer = layers.find(function (bl) { return (l === bl); });\n        });\n        // Did we find the layer?\n        if (null != foundLayer) {\n            // Yes - set the baselayer to the one we found\n            this.baseLayer = foundLayer;\n        }\n        else {\n            // No - set the baselayer to the first in the array and add it to the map\n            if (layers.length > 0) {\n                this.baseLayer = layers[0];\n                // Add layers outside of angular to prevent events from triggering change detection\n                this.zone.runOutsideAngular(function () {\n                    _this.baseLayer.addTo(map);\n                });\n            }\n        }\n    };\n    __decorate([\n        Input('leafletBaseLayers'),\n        __metadata(\"design:type\", Object),\n        __metadata(\"design:paramtypes\", [Object])\n    ], LeafletBaseLayersDirective.prototype, \"baseLayers\", null);\n    __decorate([\n        Input('leafletLayersControlOptions'),\n        __metadata(\"design:type\", Object)\n    ], LeafletBaseLayersDirective.prototype, \"layersControlOptions\", void 0);\n    __decorate([\n        Output('leafletLayersControlReady'),\n        __metadata(\"design:type\", Object)\n    ], LeafletBaseLayersDirective.prototype, \"layersControlReady\", void 0);\n    LeafletBaseLayersDirective = __decorate([\n        Directive({\n            selector: '[leafletBaseLayers]'\n        }),\n        __metadata(\"design:paramtypes\", [LeafletDirective, KeyValueDiffers, NgZone])\n    ], LeafletBaseLayersDirective);\n    return LeafletBaseLayersDirective;\n}());\nexport { LeafletBaseLayersDirective };\n"],"mappings":"AAAA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,CAAC,EAAEC,CAAC,EAAE;EAC1D,IAAI,OAAON,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACO,QAAQ,KAAK,UAAU,EAAE,OAAOP,OAAO,CAACO,QAAQ,CAACF,CAAC,EAAEC,CAAC,CAAC;AAC5G,CAAC;AACD,SAASE,SAAS,EAAEC,YAAY,EAAEC,KAAK,EAAEC,eAAe,EAAEC,MAAM,EAAEC,MAAM,QAAQ,eAAe;AAC/F,SAASC,OAAO,QAAQ,SAAS;AACjC,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,uBAAuB,QAAQ,sCAAsC;AAC9E,SAASC,2BAA2B,QAAQ,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,0BAA0B,GAAG,aAAe,YAAY;EACxD,SAASA,0BAA0BA,CAACC,gBAAgB,EAAEC,OAAO,EAAEC,IAAI,EAAE;IACjE,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB;IACA,IAAI,CAACC,kBAAkB,GAAG,IAAId,YAAY,CAAC,CAAC;IAC5C,IAAI,CAACW,gBAAgB,GAAG,IAAIH,uBAAuB,CAACG,gBAAgB,CAAC;IACrE,IAAI,CAACI,aAAa,GAAG,IAAIN,2BAA2B,CAAC,IAAI,CAACI,IAAI,EAAE,IAAI,CAACC,kBAAkB,CAAC;IACxF,IAAI,CAACE,gBAAgB,GAAG,IAAI,CAACJ,OAAO,CAACK,IAAI,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;EAC1D;EACA9B,MAAM,CAACM,cAAc,CAACgB,0BAA0B,CAACS,SAAS,EAAE,YAAY,EAAE;IACtEC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,eAAe;IAC/B,CAAC;IACD;IACAC,GAAG,EAAE,SAAAA,CAAUzB,CAAC,EAAE;MACd,IAAI,CAACwB,eAAe,GAAGxB,CAAC;MACxB,IAAI,CAAC0B,gBAAgB,CAAC,CAAC;IAC3B,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFf,0BAA0B,CAACS,SAAS,CAACO,WAAW,GAAG,YAAY;IAC3D,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,CAACZ,aAAa,CAACa,gBAAgB,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;EAClD,CAAC;EACDnB,0BAA0B,CAACS,SAAS,CAACW,QAAQ,GAAG,YAAY;IACxD,IAAIC,KAAK,GAAG,IAAI;IAChB;IACA,IAAI,CAACpB,gBAAgB,CAACqB,IAAI,CAAC,CAAC;IAC5B;IACA,IAAI,CAACnB,IAAI,CAACoB,iBAAiB,CAAC,YAAY;MACpC;MACAF,KAAK,CAAChB,aAAa,CACdiB,IAAI,CAAC,CAAC,CAAC,EAAED,KAAK,CAACG,oBAAoB,CAAC,CACpCC,KAAK,CAACJ,KAAK,CAACpB,gBAAgB,CAACyB,MAAM,CAAC,CAAC,CAAC;IAC/C,CAAC,CAAC;IACF,IAAI,CAACb,gBAAgB,CAAC,CAAC;EAC3B,CAAC;EACDb,0BAA0B,CAACS,SAAS,CAACkB,SAAS,GAAG,YAAY;IACzD,IAAI,CAACd,gBAAgB,CAAC,CAAC;EAC3B,CAAC;EACDb,0BAA0B,CAACS,SAAS,CAACI,gBAAgB,GAAG,YAAY;IAChE,IAAIe,GAAG,GAAG,IAAI,CAAC3B,gBAAgB,CAACyB,MAAM,CAAC,CAAC;IACxC,IAAIG,aAAa,GAAG,IAAI,CAACxB,aAAa,CAACa,gBAAgB,CAAC,CAAC;IACzD,IAAI,IAAI,IAAIU,GAAG,IAAI,IAAI,IAAIC,aAAa,IAAI,IAAI,IAAI,IAAI,CAACvB,gBAAgB,EAAE;MACvE,IAAIwB,OAAO,GAAG,IAAI,CAACxB,gBAAgB,CAACyB,IAAI,CAAC,IAAI,CAACpB,eAAe,CAAC;MAC9D,IAAIqB,OAAO,GAAG,IAAI,CAAC3B,aAAa,CAAC4B,qBAAqB,CAACH,OAAO,CAAC;MAC/D,IAAIE,OAAO,CAACE,OAAO,CAAC,CAAC,EAAE;QACnB,IAAI,CAACC,aAAa,CAAC,CAAC;MACxB;IACJ;EACJ,CAAC;EACD;AACJ;AACA;EACInC,0BAA0B,CAACS,SAAS,CAAC0B,aAAa,GAAG,YAAY;IAC7D,IAAId,KAAK,GAAG,IAAI;IAChB,IAAIO,GAAG,GAAG,IAAI,CAAC3B,gBAAgB,CAACyB,MAAM,CAAC,CAAC;IACxC,IAAIU,MAAM,GAAGxC,WAAW,CAACyC,UAAU,CAAC,IAAI,CAACpB,UAAU,CAAC;IACpD,IAAIqB,UAAU;IACd;IACAV,GAAG,CAACW,SAAS,CAAC,UAAUC,CAAC,EAAE;MACvBF,UAAU,GAAGF,MAAM,CAAC7B,IAAI,CAAC,UAAUkC,EAAE,EAAE;QAAE,OAAQD,CAAC,KAAKC,EAAE;MAAG,CAAC,CAAC;IAClE,CAAC,CAAC;IACF;IACA,IAAI,IAAI,IAAIH,UAAU,EAAE;MACpB;MACA,IAAI,CAACI,SAAS,GAAGJ,UAAU;IAC/B,CAAC,MACI;MACD;MACA,IAAIF,MAAM,CAAC5D,MAAM,GAAG,CAAC,EAAE;QACnB,IAAI,CAACkE,SAAS,GAAGN,MAAM,CAAC,CAAC,CAAC;QAC1B;QACA,IAAI,CAACjC,IAAI,CAACoB,iBAAiB,CAAC,YAAY;UACpCF,KAAK,CAACqB,SAAS,CAACjB,KAAK,CAACG,GAAG,CAAC;QAC9B,CAAC,CAAC;MACN;IACJ;EACJ,CAAC;EACD3D,UAAU,CAAC,CACPsB,KAAK,CAAC,mBAAmB,CAAC,EAC1BN,UAAU,CAAC,aAAa,EAAEP,MAAM,CAAC,EACjCO,UAAU,CAAC,mBAAmB,EAAE,CAACP,MAAM,CAAC,CAAC,CAC5C,EAAEsB,0BAA0B,CAACS,SAAS,EAAE,YAAY,EAAE,IAAI,CAAC;EAC5DxC,UAAU,CAAC,CACPsB,KAAK,CAAC,6BAA6B,CAAC,EACpCN,UAAU,CAAC,aAAa,EAAEP,MAAM,CAAC,CACpC,EAAEsB,0BAA0B,CAACS,SAAS,EAAE,sBAAsB,EAAE,KAAK,CAAC,CAAC;EACxExC,UAAU,CAAC,CACPyB,MAAM,CAAC,2BAA2B,CAAC,EACnCT,UAAU,CAAC,aAAa,EAAEP,MAAM,CAAC,CACpC,EAAEsB,0BAA0B,CAACS,SAAS,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;EACtET,0BAA0B,GAAG/B,UAAU,CAAC,CACpCoB,SAAS,CAAC;IACNsD,QAAQ,EAAE;EACd,CAAC,CAAC,EACF1D,UAAU,CAAC,mBAAmB,EAAE,CAACY,gBAAgB,EAAEL,eAAe,EAAEC,MAAM,CAAC,CAAC,CAC/E,EAAEO,0BAA0B,CAAC;EAC9B,OAAOA,0BAA0B;AACrC,CAAC,CAAC,CAAE;AACJ,SAASA,0BAA0B"},"metadata":{},"sourceType":"module","externalDependencies":[]}